from __future__ import annotations

import json
import random
from pathlib import Path
from typing import List

from .self_acquisition import SelfAcquisition, AcquisitionResult
from .self_compression import SelfCompression, CompressionInput
from .self_tooling import SelfTooling, ToolPlan


class SelfExpansionEngine:
    """
    Self-Expansion Engine 오케스트레이터 (스켈레톤)
    - Self-Acquisition → Self-Compression → Self-Tooling 순서로 단일 사이클 실행
    - 현재는 placeholder 동작이며, 실제 수집/압축/도구 생성 로직을 확장해야 함.
    """

    def __init__(self, workspace_root: Path):
        self.workspace_root = workspace_root
        outputs = workspace_root / "outputs"
        memory = workspace_root / "memory"
        tools = workspace_root / "tools" / "auto_generated"
        cache = outputs / "sync_cache"

        self.acquisition = SelfAcquisition(cache_dir=cache)
        self.compression = SelfCompression(outputs_dir=outputs, memory_dir=memory)
        self.tooling = SelfTooling(tools_dir=tools)

        # 기본 소스 등록 (확장 지점)
        self.acquisition.register_source(self._dummy_source)
        self.acquisition.register_file_sampler(str(outputs / "*.json"))
        self.acquisition.register_recent_log_tail(log_dir=workspace_root / "logs")
        # memory sampler (state)
        self.acquisition.register_file_sampler(str(memory / "*.json"))
        # Lua conversation sampler (있으면 자동 포함)
        self.acquisition.register_lua_conversation_sampler(workspace_root / "ai_binoche_conversation_origin" / "rua")

    def _dummy_source(self) -> AcquisitionResult:
        payload = {"signal": random.random()}
        meta = {"phase": "dummy", "value": payload["signal"]}
        return AcquisitionResult(source="dummy", payload=payload, meta=meta)

    def run_acquisition(self, batch_size: int = 3, max_time: float = 2.0) -> List[AcquisitionResult]:
        return self.acquisition.acquire_batch(batch_size=batch_size, max_time=max_time)

    def run_compression(self, acquired: List[AcquisitionResult]) -> dict:
        comp_inputs: List[CompressionInput] = [
            CompressionInput(source=a.source, payload=a.payload, meta=a.meta) for a in acquired
        ]
        return self.compression.compress(comp_inputs)

    def run_tooling(self, plan: ToolPlan | None = None) -> dict:
        if plan is None:
            # 툴 생성 예시(placeholder)
            plan = ToolPlan(
                name="auto_generated_probe",
                description="Placeholder tool generated by Self-Tooling",
                entrypoint="main",
                code="def main():\n    return 'ok'\n",
            )
        return self.tooling.register(plan)

    def run_once(self) -> dict:
        acquired = self.run_acquisition(batch_size=3, max_time=2.0)
        summary = self.run_compression(acquired)
        tool_info = self.run_tooling()

        result = {"acquired": len(acquired), "compressed": summary, "tool": tool_info}

        # 상태 캐시 저장 (표준: outputs/sync_cache/self_expansion_state.json)
        cache_dir = self.workspace_root / "outputs" / "sync_cache"
        cache_dir.mkdir(parents=True, exist_ok=True)
        state_file = cache_dir / "self_expansion_state.json"
        try:
            state_file.write_text(
                json.dumps(result, ensure_ascii=False, indent=2),
                encoding="utf-8",
            )
        except Exception:
            pass

        return result
